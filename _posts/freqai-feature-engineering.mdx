---
title: "Trading with FreqAI: Advanced Feature Engineering for Market Forecasting"
slug: vector-databases
date: "2024-22-07"
description: "Embark on a journey through the revolutionary realm of Vector Databases. Discover how these powerful data engines are reshaping the landscape of data management and AI applications in 2024."
author: "Vadim Nicolai"
---

FreqAI is a powerful tool designed to automate various tasks associated with training a predictive machine learning model to generate market forecasts. One of the key aspects of FreqAI is feature engineering, which allows users to create and manage a wide array of features that enhance the predictive capabilities of their models. In this article, we'll explore how to define, expand, and customize features using FreqAI.

#### Defining Features

Feature engineering in FreqAI involves defining base features within a set of functions called `feature_engineering_*`. These functions set the base features such as RSI, MFI, EMA, SMA, time of day, volume, etc. You can use custom indicators or import them from any technical-analysis library. FreqAI simplifies large-scale feature engineering with the following functions:

- **feature_engineering_expand_all()**: Automatically expands the defined features across various timeframes, shifted candles, and correlated pairs.
- **feature_engineering_expand_basic()**: Expands features across timeframes, shifted candles, and correlated pairs without duplicating across indicator periods.
- **feature_engineering_standard()**: Called once with the dataframe of the base timeframe for custom exotic feature extractions.
- **set_freqai_targets()**: Sets the targets for the model. All targets must be prepended with `&` to be recognized by FreqAI internals.

Here's an example of how to set indicators and labels in the strategy:

```python
def feature_engineering_expand_all(self, dataframe: DataFrame, period, metadata, **kwargs) -> DataFrame:
    dataframe["%-rsi-period"] = ta.RSI(dataframe, timeperiod=period)
    dataframe["%-mfi-period"] = ta.MFI(dataframe, timeperiod=period)
    dataframe["%-adx-period"] = ta.ADX(dataframe, timeperiod=period)
    dataframe["%-sma-period"] = ta.SMA(dataframe, timeperiod=period)
    dataframe["%-ema-period"] = ta.EMA(dataframe, timeperiod=period)

    bollinger = qtpylib.bollinger_bands(
        qtpylib.typical_price(dataframe), window=period, stds=2.2
    )
    dataframe["bb_lowerband-period"] = bollinger["lower"]
    dataframe["bb_middleband-period"] = bollinger["mid"]
    dataframe["bb_upperband-period"] = bollinger["upper"]

    dataframe["%-bb_width-period"] = (
        dataframe["bb_upperband-period"] - dataframe["bb_lowerband-period"]
    ) / dataframe["bb_middleband-period"]
    dataframe["%-close-bb_lower-period"] = dataframe["close"] / dataframe["bb_lowerband-period"]

    dataframe["%-roc-period"] = ta.ROC(dataframe, timeperiod=period)
    dataframe["%-relative_volume-period"] = dataframe["volume"] / dataframe["volume"].rolling(period).mean()

    return dataframe
```

#### Expanding Features

After defining the base features, you can expand upon them using the `feature_parameters` in the configuration file. This allows you to include additional timeframes, correlated pairs, and recent candles. Hereâ€™s an example configuration:

```json
"freqai": {
    "feature_parameters": {
        "include_timeframes": ["5m", "15m", "4h"],
        "include_corr_pairlist": ["ETH/USD", "LINK/USD", "BNB/USD"],
        "label_period_candles": 24,
        "include_shifted_candles": 2,
        "indicator_periods_candles": [10, 20]
    }
}
```

In this configuration:

- `include_timeframes` specifies the timeframes for each call to `feature_engineering_expand_*()`.
- `include_corr_pairlist` includes features for correlated pairs.
- `include_shifted_candles` indicates the number of previous candles to include.
- `indicator_periods_candles` sets the periods for indicators.

The total number of features created is the product of the lengths of these parameters.

#### Customizing the Pipeline

FreqAI builds a dynamic pipeline based on user configuration settings. You can activate additional steps with more configuration parameters. For instance, adding `use_SVM_to_remove_outliers: true` will automatically add the `SVMOutlierExtractor` to the pipeline. You can customize the pipeline further by defining your own data pipeline in your IFreqaiModel:

```python
from datasieve.transforms import SKLearnWrapper, DissimilarityIndex
from datasieve.pipeline import Pipeline
from sklearn.preprocessing import QuantileTransformer, StandardScaler

class MyFreqaiModel(BaseRegressionModel):
    def fit(self, data_dictionary: Dict, dk: FreqaiDataKitchen, **kwargs) -> Any:
        model = cool_model.fit()
        return model

    def define_data_pipeline(self) -> Pipeline:
        feature_pipeline = Pipeline([
            ('qt', SKLearnWrapper(QuantileTransformer(output_distribution='normal'))),
            ('di', ds.DissimilarityIndex(di_threshold=1))
        ])
        return feature_pipeline

    def define_label_pipeline(self) -> Pipeline:
        label_pipeline = Pipeline([
            ('qt', SKLearnWrapper(StandardScaler())),
        ])
        return label_pipeline
```

#### Outlier Detection

Equity and crypto markets often contain a high level of non-patterned noise in the form of outlier data points. FreqAI implements several methods to identify and mitigate these outliers:

- **Dissimilarity Index (DI)**: Measures the distance between each training data point and all other training data points to identify outliers.
- **Support Vector Machine (SVM)**: Trains an SVM on the training data to identify and remove outlier data points.
- **DBSCAN**: Uses DBSCAN clustering to identify and remove outliers from the training/test data set.

#### Data Dimensionality Reduction

You can reduce the dimensionality of your features by activating the principal_component_analysis in the config:

```json
"freqai": {
    "feature_parameters": {
        "principal_component_analysis": true
    }
}
```

This performs PCA on the features, reducing their dimensionality while maintaining the explained variance of the dataset.

### Conclusion

Feature engineering is a crucial step in building effective predictive models with FreqAI. By defining, expanding, and customizing features, you can enhance the model's ability to forecast market movements accurately. FreqAI provides a robust framework for feature engineering, making it easier for users to create and manage large-scale feature sets.
